% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline.R
\name{mergeMulti}
\alias{mergeMulti}
\title{mergeMulti}
\usage{
mergeMulti(MA, mc.cores = getOption("mc.cores", 1L), ...)
}
\arguments{
\item{MA}{\code{\link{MultiAmplicon-class}} object with derep and
dada slots filled.}

\item{mc.cores}{number or compute cores for parallel merging of
different amplicons (values > 1 are only allowed on Unix/Linux
systems).}

\item{...}{additional arguments to be passed to the
\code{\link[dada2]{mergePairs}} function of \code{dada2}, all
arguments to the function can be given as a vector of the same
length as the number of primer pairs in the MultiAmplicon
object, allowing to specify e.g. justConcatenate to be set
TRUE for only some of the amplicons, or to specify different
minOverlap for each amplicon. If a shorter vector is given it
will be recycled to match the number of amplicons.}
}
\value{
A MultiAmplicon-class object with the mergers slot filled.
}
\description{
Merge denoised pairs of forward and reverse reads inside an
MultiAmplicon object.
}
\details{
This is a wrapper for \code{\link[dada2]{mergePairs}} from
\code{dada2}. It works on an \code{\link{MultiAmplicon-class}}
object with derep and dada slots filled. Use
\code{\link{dadaMulti}} and \code{\link{derepMulti}} on a amplicon
sorted (see \code{\link{sortAmplicons}})
\code{\link{MultiAmplicon-class}} object to preprocess your
multi-marker data to this point.
}
\author{
Emanuel Heitlinger
}
