---
title: "MultiAmplicon - a small example"
author: "Emanuel Heitlinger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Preparing sequencing read files and a primer set

The MultiAmplicon package uses dedicated classes to ensure that input
to its `sortAmplicons` function is provided correctly. Concerning
input files, this means for the user that file names (including paths
to the directory they are stored in) of forward and reverse sequencing
read files must be provided as a `PairedReadFileSet`. These files can
contain reads in fastq or in gzipped fastq format. We focus as a
default use case on (non-interleaved) paired-end reads, as these are
the most common format Illumina sequencing reads are currently
produced in (but see vignette xyz as an example how to process
single-end sequencing data).

Similarly, primer pairs must be provided in a `PrimerPairsSet`. We
then match forward and reverse primers at the start of forward and
reverse reads, respectively. The maximal number of missmatches and the
maximal distance from the start of the read can be supplied as
arguments to the function. The primer sequences are trimmed from the
reads and the read-pair is associated with the amplicon defined by the
primer-pair. While we focus on this default use case, the package can
als be used adaptor trimming with a single primer (see vignette xyz).

But to go on with our main intended use case example first have a look
at how `PairedReadFileSet` and `PrimerPairsSet` are generated.

Please use files containing quality filtered sequencing reads for the
steps below. See the
[dada2 tutorial](https://benjjneb.github.io/dada2/tutorial.html) or
our [real-world data vignette](https:/foobarXYZXYZ.foo).


```{r buildup, message=FALSE}
library(MultiAmplicon)

primerF <- c(Amp1F = "AGAGTTTGATCCTGGCTCAG", Amp2F = "ACTCCTACGGGAGGCAGC",
             Amp3F = "GAATTGACGGAAGGGCACC", Amp4F = "YGGTGRTGCATGGCCGYT",
             Amp5F = "AAAAACCCCGGGGGGTTTTT", Amp6F = "AGAGTTTGATCCTGCCTCAG")

primerR <- c(Amp1R = "CTGCWGCCNCCCGTAGG", Amp2R = "GACTACHVGGGTATCTAATCC",
             Amp3R = "AAGGGCATCACAGACCTGTTAT", Amp4R = "TCCTTCTGCAGGTTCACCTAC",
             Amp5R = "AAAAACCCCGGGGGGTTTTT", Amp6R = "CCTACGGGTGGCAGATGCAG")

PPS <- PrimerPairsSet(primerF, primerR)

fastq.dir <- system.file("extdata", "fastq", package = "MultiAmplicon")
fastq.files <- list.files(fastq.dir, full.names=TRUE)

Ffastq.file <- fastq.files[grepl("F_filt", fastq.files)]
Rfastq.file <- fastq.files[grepl("R_filt", fastq.files)]

PRF <- PairedReadFileSet(Ffastq.file, Rfastq.file)

MA <- MultiAmplicon(PPS, PRF)
```

Note that the primer pairs in the `PrimerPairsSet` can be named and
the same also is true for the sequencing read file pairs (although not
in our example above). This results in names for primer-pairs and for
samples.


## Sorting into multiple amplicons

Based on the primer sequences we can now sort the sequences into
amplicons. This is done by the function `sortAmplicons`, which updates
the MultiAmplicon object with the sorted amplicons.

For this small example dataset we can look at the resuling `rawCounts`
i.e. the number of sequences for each of the fully stratified amplicon
x sample matrix. 

```{r sortAmplicon, message=FALSE}
MA1 <- sortAmplicons(MA)
```

```{r showRC, results='asis'}
knitr::kable(rawCounts(MA1))
```

## Visualizing read numbers per amplicon and filtering based on these

Now we can plot the result. The function plotAmpliconNumbers allows us
also to store clustering information (see \code{pheatmap}). Which can
afterwards be used to filter data.

```{r plotAmpliconNumbers, fig.show='hold'}
clusters <- plotAmpliconNumbers(MA1)
```

We can use this clustering information now to subset our MultiAmplicon
object.


```{r subsetCluster, result='asis'}
two.clusters.row <- cutree(clusters$tree_row, k=2)
two.clusters.col <- cutree(clusters$tree_col, k=2)

knitr::kable(two.clusters.row)
knitr::kable(two.clusters.col)

MA.sub <- MA1[which(two.clusters.row==1), which(two.clusters.col==2)]

knitr::kable(rawCounts(MA.sub))
```

In real world applications (see vignette xyz) the samples to be
excluded from further analysis can be selected based on clustering
with negative controls (similar to the example data here where S00 is
an empty file and S01 contains one sequence).

## Running the amplicon sequencing pipline 


We first estimate the errors seperately for both for dada's
probabilistic sequence variant inference. We do this here on the
combined statified files for different amplicons. This should be done
separately for forward ad reverse sequence though!

```{r errEst, cache=TRUE, message=FALSE}
errF <- learnErrors(unlist(stratifiedFilesF(MA1)), nread=1e6,
                    verbose=0)
errR <- learnErrors(unlist(stratifiedFilesR(MA1)), nread=1e6,
                    verbose=0)
```

We can now run the pipeline of the dada2 package in parallel over the
different amplicons. We update our object from each previous step and
safe it under a new name, here for illustration. In your own workflow
you can also overwrite the old object.


```{r pipeline, cache=TRUE, message=FALSE}
MA2 <- derepMulti(MA.sub)

MA3 <- dadaMulti(MA2, Ferr=errF, Rerr=errR,  pool=FALSE)

MA4 <- mergeMulti(MA3)

MA5 <- sequenceTableMulti(MA4)

MA6 <- noChimeMulti(MA5)
```

Ready! This was *easy*, right?


## A word on dada2 sequence inference

The above workflow assumes that errors could be estimated for each
amplicon together. This would be beneficial if erros were largely
similar between different amplicons (i.e. not influenced by the primer
starting the sequence). Below an alternative approach is demonstrated
with error probabilities estimated seperately for each amplicon (here
also overwrite objects from each previous processing steps).


```{r altdada, cache=TRUE, message=FALSE}
MA.alt <- dadaMulti(MA2, selfConsist=TRUE, pool=FALSE)

MA.alt <- mergeMulti(MA.alt)

MA.alt <- sequenceTableMulti(MA.alt)

MA.alt <- noChimeMulti(MA.alt)
```

## Using different parameters for each amplicon

In some real world applications it might be desireable to have more
control over paramters used in the pipeline for different amplicons.

We use ellipsis (aka "...", dots, dot-dot-dot or three-dots) to pass
parameters on to the underlying dada2 functions. The MultiAmplicon
package allows all those arguments to be vectors with values varying
for different amplicons.

Let's suppose for this we e.g. want to merge a subset of our
amplicons, while we concatenate others using N's. 


```{r mixdata, cache=TRUE}
MA.mixed <- mergeMulti(MA3, justConcatenate=c(TRUE, FALSE, FALSE, TRUE))
```
The above example would make sense if amlicons Amp1F.Amp1R and
Amp4F.Amp4R (1st and 4th in our object) had too little overalap
between forward and revese reads to be merged and would better be
concatenated.
