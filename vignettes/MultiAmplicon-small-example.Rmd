---
title: "Multi Amplicon - a small example"
author: "Emanuel Heitlinger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Multi Amplicon - a small example

The MultiAmplicon-package allows the matching and removal of primer
sequences from sequencing reads. Amplicons, here defined as the
sequences amplified by particular combionation of forward and reverse
primer, can then be further processed. The package further guiedes
downstream analysis of multiple amplicons in a bioconductor workflow
wrapped around the package dada2 (and phyloseq).

## Preparing sequencing read files and a primer set

The MultiAmplicon package uses dedicated classes to ensure that input
to its `sortAmplicons` function is provided correctly. Concerning
input files, this means for the user that file names (including paths
to the directory they are stored in) of forward and reverse sequencing
read files must be provided as a `PairedReadFileSet`. These files can
contain reads in fastq or in gzipped fastq format. We focus as a
default use case on (non-interleaved) paired-end reads, as these are
the most common format Illumina sequencing reads are currently
produced in (but see vignette xyz as an example how to process
single-end sequencing data).

Similarly, primer pairs must be provided in a `PrimerPairsSet`. We
then match forward and reverse primers at the start of forward and
reverse reads, respectively. The maximal number of missmatches and the
maximal distance from the start of the read can be supplied as
arguments to the function. The primer sequences are trimmed from the
reads and the read-pair is associated with the amplicon defined by the
primer-pair. While we focus on this default use case, the package can
als be used adaptor trimming with a single primer (see vignette xyz).

But to go on with our main intended use case example first have a look
at how `PairedReadFileSet` and `PrimerPairsSet` are generated.

```{r buildup}
suppressMessages(library(MultiAmplicon))

primerF <- c(Amp1F = "AGAGTTTGATCCTGGCTCAG", Amp2F = "ACTCCTACGGGAGGCAGC",
             Amp3F = "GAATTGACGGAAGGGCACC", Amp4F = "YGGTGRTGCATGGCCGYT",
             Amp5F = "AAAAACCCCGGGGGGTTTTT", Amp6F = "AGAGTTTGATCCTGCCTCAG")

primerR <- c(Amp1R = "CTGCWGCCNCCCGTAGG", Amp2R = "GACTACHVGGGTATCTAATCC",
             Amp3R = "AAGGGCATCACAGACCTGTTAT", Amp4R = "TCCTTCTGCAGGTTCACCTAC",
             Amp5R = "AAAAACCCCGGGGGGTTTTT", Amp6R = "CCTACGGGTGGCAGATGCAG")

PPS <- PrimerPairsSet(primerF, primerR)

fastq.dir <- system.file("extdata", "fastq", package = "MultiAmplicon")
fastq.files <- list.files(fastq.dir, full.names=TRUE)

Ffastq.file <- fastq.files[grepl("F_filt", fastq.files)]
Rfastq.file <- fastq.files[grepl("R_filt", fastq.files)]

PRF <- PairedReadFileSet(Ffastq.file, Rfastq.file)

MA <- MultiAmplicon(PPS, PRF)
```

Note that the primer pairs in the `PrimerPairsSet` can be named and
the same also is true for the sequencing read file pairs (although not
in our example above). This results in names for primer-pairs and for
samples.





## Sorting into multiple amplicons

Based on the primer sequences we can now sort the sequences into
amplicons. This is done by the function `sortAmplicons`, which updates
the MultiAmplicon object with the sorted amplicons.

For this small example dataset we can look at the resuling `rawCounts`
i.e. the number of sequences for each of the fully stratified amplicon
x sample matrix. 

```{r sortAmplicon, message = FALSE}
MA1 <- sortAmplicons(MA)
```

```{r showRC, results='asis'}
knitr::kable(rawCounts(MA1))
```

Now we can plot the result. The function plotAmpliconNumbers allows us
also to store clustering information (see \code{pheatmap}). Which can
afterwards be used to filter data.

```{r plotAmpliconNumbers, fig.show='hold'}
clusters <- plotAmpliconNumbers(MA1)
```

We can use this clustering information now to subset our MultiAmplicon
object.


```{r subsetCluster}
two.clusters.row <- cutree(clusters$tree_row, k=2)
two.clusters.col <- cutree(clusters$tree_col, k=2)
```

